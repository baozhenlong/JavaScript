//---二进制位运算符

//1---概述
{
    //二进制位运算符用于直接对二进制位进行计算，一共7个：
    {
        //二进制或运算符：|，表示若2个二进制位都为0，则结果为0，否则为1
        //二进制与运算符：&，表示若2个二进制位都为1，则结果为1，否则为0
        //二进制否运算符：~，表示对一个二进制位取反
        //异或运算符：^，表示若2个二进制位不相同，则结果为1，否则为0
        //左移运算符：<<
        //右移运算符：>>
        //带符号位的右移运算符：>>>
    }
    //这些位运算符直接处理每一个比特位，所以是非常底层的运算
    //好处是速度极快；缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错
    //注意：位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行
    //虽然在JavaScript内部，数值都是以64为浮点数的形式存储
    //但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数
    //将任意数值转为32位整数
    function to_int_32(x) {
        return x | 0;
    }
    console.log('[概述]---将任意数值转为32位整数 ', to_int_32(1.001)); //1
    console.log('[概述]---将任意数值转为32位整数 ', to_int_32(1.999)); //1
    console.log('[概述]---将任意数值转为32位整数 ', to_int_32(1)); //1
    console.log('[概述]---将任意数值转为32位整数 ', to_int_32(-1)); //-1
    console.log('[概述]---将任意数值转为32位整数 ', to_int_32(Math.pow(2, 32) + 1)); //1
    console.log('[概述]---将任意数值转为32位整数 ', to_int_32(Math.pow(2, 32) - 1)); //-1
    //对于大于或等于2^32的整数，大于32位的数位都会被舍去
}

//2---二进制或运算符
{
    //|：逐位比较2个运算子，2个二进制位之中只要一个为1,就返回1，否则返回0
    console.log('[|]---', 0 | 3); //3
    //00和11，得到11，即3
    //位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分
    console.log('[|]---', 0 | 2); //2
    console.log('[|]---', 0 | -2); //-2
    //注意：这种取整方法不适用超过32位整数最大值2147483647的数
}

//3---二进制与运算符
{
    //&：逐位比较2个运算子，2个二进制之中只要有一个为0,这就返回0,否则返回1
    console.log('[&]---', 0 & 3); //0
    //00和11，得到00，即0
}

//4---二进制否运算符
{
    //~：将每个二进制位都变为相反值(0变1,1变0)
    console.log('[~]---', ~3); //-4
    //3的32位整数形式：00000000000000000000000000000011
    //11111111111111111111111111111100：第一位(符号位)是1，所以这是一个负数
    //JavaScript内部采用补码形式表示负数
    //即需要将这个数减1.再取一次反，然后加上负号，才能得到这个负数对应的10进制值
    //减1：11111111111111111111111111111011
    //取反：00000000000000000000000000000100
    //加上负号：-4
    //简单记忆：一个数 + 自身的取反值 === -1
    //对一个整数连续2次二进制否运算，得到它自身
    console.log('[~]---', ~~-3); //-3
    //所有的位运算都只对整数有效
    //二进制否运算符遇到小数时，也会将小数部分舍去，只保留整数部分
    //所以，对一个小数连续进行2次二进制否运算，能达到取整效果
    console.log('[~]---', ~~2.9); //2
    console.log('[~]---', ~~47.1); //47
    console.log('[~]---', ~~3); //3
    //使用二进制否运算取整，是所有取整方法中最快的一种
    //对于其他类型的值，二进制否运算先用Number转为数值，然后再进行处理
}

//5---异或运算符
{
    //^：在2个二进制位不同时返回1，相同时返回0
    console.log('[^]---', 0 ^ 3); //3
    //00和11，得到11，即3
    //特殊运用：连续对2个数进行3次异或运算，可以互换它们的值
    //这意味着，使用"异或运算符"可以在不引入临时变量的前提下，互换2个变量的值
    var a = 10;
    var b = 99;
    a ^= b;
    b ^= a;
    a ^= b;
    console.log('[^]---', a); //99
    console.log('[^]---', b); //10
    //这是互换2个变量的值的最快方法
    //异或运算也可以用来取整
    console.log('[^]---', 12.9 ^ 0); //12
}

//6---左移运算符
{
    //<<：表示将一个数的二进制值向左移动指定的位数，尾部补0；即乘以2的指定次方
    //4的二进制形式为100
    //左移一位位1000(即十进制的8)
    //相当于乘以2的1次方
    console.log('[<<]---', 4 << 1); //8
    console.log('[<<]---', -4 << 1); //-8
    //-4的二进制形式：11111111111111111111111111111100
    //左移一位：11111111111111111111111111111000
    //转为十进制：(减一后取反，再加上负号)：-8
    //如果左移0位，就相当于将该数值转为32位整数，等同于取整
    console.log('[<<]---', 13.5 << 0); //13
    console.log('[<<]---', -13.5 << 0); //-13
}

//7---右移运算符
{
    //>>：表示将一个数的二进制值向右移动指定的位数，头部补0；即除以2的指定次方(最高位即符号位不参与移动)
    console.log('[>>]---', 4 >> 1); //2
    //4的二进制形式：00000000000000000000000000000100
    //右移一位：00000000000000000000000000000010
    console.log('[>>]---', -4 >> 1); //-2  
    //-4的二进制形式为 11111111111111111111111111111100
    //右移一位，头部补1：11111111111111111111111111111110
    //右移运算可以模拟2的整除运算
    console.log('[>>]---', 5 >> 1); //2
    //相当于5 / 2
    console.log('[>>]---', 21 >> 2); //5
    //相当于21 / 4
    console.log('[>>]---', 21 >> 3); //2
    //相当于21 / 8
    console.log('[>>]---', 21 >> 4); //1
    //相当于21 / 16
}

//8---带符号位的右移运算符
{
    //>>>：表示将一个数的二进制形式向右移动，包括符号位也参与移动，头部补0
    //所以：该运算总是得到正值
    //对于正数，该运算的结果与右移运算符(>>)完全一致，区别主要在于负数
    console.log('[>>>]---', 4 >>> 1); //2
    console.log('[>>>]---', -4 >>> 1); //2147483646
    //-4的二进制形式为 11111111111111111111111111111100
    //右移一位，头部补1：01111111111111111111111111111110
    //这个运算实际上将一个值转为32位无符号整数
    //查看一个负整数在计算机内部的存储形式最快的方法就是使用>>>
}

//9---开关作用
{
    //位运算符可以用作设置对象属性的开关
    //假定某个对象有四个开关，每个开关都是一个变量；那么，可以设置一个四位的二进制数，它的每个位对应一个开关
    var flag_a = 1; //0001
    var flag_b = 2; //0010
    var flag_c = 4; //0100
    var flag_d = 8; //1000
    //上面代码设置 a、b、c、d 四个开关，每个开关分别占有一个二进制位。
    //然后，就可以用二进制与(&)运算检验，当前设置是否打开了指定开关。
    var flags = 5; // 二进制的0101
    if (flags & flag_c) {
        console.log('[开关作用]---open c');
    }
    //0101 & 0100 => 0100 => true
    //上面代码检验是否打开了开关C；如果打开，会返回true，否则返回false
    //现在假设需要打开a、b、d三个开关，我们可以构造一个掩码变量
    var mask = flag_a | flag_b | flag_d;
    //0001 | 0010 | 1000 => 1011
    //上面代码对a、b、d三个变量进行二进制或运算，得到掩码值为二进制的1011
    //有了掩码
    //二进制或运算可以确保打开指定的开关
    flags = flags | mask;
    //二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭
    flags = flags & mask;
    //异或运算可以切换(toggle)当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值
    flags = flags ^ mask;
    //二进制否运算可以翻转当前设置，即原设置为0，运算后变为1；原设置为1，运算后变为0
    flags = ~flags;
}