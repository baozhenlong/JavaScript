// 比较运算符

// 1 --- 概述
{
    // 比较运算符：比较 2 个值的大小，然后返回一个布尔值，表示是否满足指定的条件
    console.log('[比较运算符]---', 2 > 1); // true
    // 注意：比较运算符可以比较各种类型的值，不仅仅是数值
    // JavaScript一共提供了8个比较运算符
    // > 大于运算符
    // < 小于运算符
    // >= 大于或等于运算符
    // <= 小于或等于运算符
    // == 相等运算符
    // === 严格相等运算符
    // != 不相等运算符
    // !== 严格不相等运算符
    // 这 8 个比较运算符分成两类：相等比较和非相等比较
    // 对于非相等的比较：算法是先看两个运算子是否都是字符串；是-就按字典顺序比较，否-将两个运算子都转成数值，再比较数值的大小
}

// 2 --- 非相等运算符：字符串的比较
{
    // 字符串按照字典顺序进行比较
    console.log('[非相等运算符]---字符串的比较 ', 'cat' > 'dog'); // false
    console.log('[非相等运算符]---字符串的比较 ', 'cat' > 'catalog'); // false
    console.log('[非相等运算符]---字符串的比较 ', 'cat' <= 'catalog'); // true
    // JavaScript 引擎内部首先比较首字符的 Unicode 码点；如果相等，再比较第二个字符的 Unicode 码点，以此类推
    console.log('[非相等运算符]---字符串的比较 ', 'cat' > 'Cat'); //true
    // 小写 c 的 Unicode 码点(99)大于大写 C 的 Unicode 码点(67)
    // 所有字符都有 Unicode 码点，因此汉字也可以比较
    console.log('[非相等运算符]---字符串的比较 ', '大' > '小'); // false
    // "大"的 Unicode 码点是 22823 ，"小"的 Unicode 码点是 23567 ，因此返回 false
}

//3---非相等运算符：非字符串的比较
{
    //如果2个运算子之中，至少一个不是字符串，需要分以下2中情况
    //3.1---原始类型值
    {
        //如果2个运算子都是原始类型的值，则先转成数值再比较
        console.log('[非相等运算符]---非字符串的比较 ', 5 > '4'); //true
        //等同于
        console.log('[非相等运算符]---非字符串的比较 ', 5 > Number('4')); //true
        console.log('[非相等运算符]---非字符串的比较 ', true > false); //true
        //等同于
        console.log('[非相等运算符]---非字符串的比较 ', Number(true) > Number(false)); //true
        console.log('[非相等运算符]---非字符串的比较 ', 2 > true); //true
        //等同于
        console.log('[非相等运算符]---非字符串的比较 ', 2 > Number(true)); //true
        //上面代码中，字符串和布尔值都会先转成数值，再进行比较
        //注意：与NaN的比较；任何值(包括NaN本身)与NaN比较，返回的都是false
    }
    //3.2---对象
    {
        //如果运算子是对象，会转为原始类型的值，再进行比较
        //对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法
        var x = [2];
        console.log('[非相等运算符]---非字符串的比较 ', x > '11'); //true
        //等同于
        console.log('[非相等运算符]---非字符串的比较 ', [2].valueOf().toString() > '11'); //true
        //即'2' > '11'        
        x.valueOf = function () {
            return '1';
        };
        console.log('[非相等运算符]---非字符串的比较 ', x > '11'); //false
        //即'1' > '11'        
        //两个对象之间的比较也是如此
        console.log('[非相等运算符]---非字符串的比较 ', [2] > [1]); //true
        //即'2' > '1'       
        console.log('[非相等运算符]---非字符串的比较 ', {
            x: 2
        } > {
            x: 1
        }); //false
        //即'[object Object]' > '[object Object]'
    }
}

//4---严格相等运算符
{
    //JavaScript提供2种相等运算符：==和===
    //相等运算符(==)：比较2个值是否相等
    //严格相等运算符(===)：比较它们是否为"同一个值"
    //如果2个值不是同一类型，严格相等运算符直接返回false，而相等运算符会将它们转换成同一个类型，再用严格相等运算符进行比较
    //4.1---不同类型的值
    {
        //如果2个值的类型不同，直接返回false
        console.log('[严格相等运算符]---不同类型的值 ', 1 === '1'); //false
        console.log('[严格相等运算符]---不同类型的值 ', true === 'true'); //false
    }
    //4.2---同一类的原始类型值
    {
        //同一类型的原始类型的值(数值、字符串、布尔值)比较时，值相同就返回true，值不相同就返回false
        console.log('[严格相等运算符]---同一类的原始类型值 ', 1 === 0x1); //true
        console.log('[严格相等运算符]---同一类的原始类型值 ', NaN === NaN); //false
        console.log('[严格相等运算符]---同一类的原始类型值 ', +0 === -0); //true
    }
    //4.3---复合类型值
    {
        //2个复合类型(对象、数组、函数)的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址
        console.log('[严格相等运算符]---复合类型值 ', {} === {}); //false
        console.log('[严格相等运算符]---复合类型值 ', [] === []); //false
        console.log('[严格相等运算符]---复合类型值 ', function () {} === function () {}); //false
        //如果2个变量引用同一个对象，则它们相等
        var v_1 = {};
        var v_2 = v_1;
        console.log('[严格相等运算符]---复合类型值 ', v_1 === v_2); //true
        //注意：对于2个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值
        var obj_1 = {
            x: 2
        };
        var obj_2 = {
            x: 1
        };
        console.log('[严格相等运算符]---复合类型值 ', obj_1 > obj_2); //false
    }
    //4.4---undefined和null
    {
        //undefined和null与自身严格相等
        console.log('[严格相等运算符]---undefined和null ', undefined === undefined); //true
        console.log('[严格相等运算符]---undefined和null ', null === null); //true
        console.log('[严格相等运算符]---undefined和null ', undefined === null); //false
        //由于变量声明后默认值是undefined，因此2个只声明未赋值的变量是相等的
        var v_1;
        var v_2;
        console.log('[严格相等运算符]---undefined和null ', v_1 === v_2); //true
    }
}

//5---严格不相等运算符
{
    //严格相等运算符有一个对应的"严格不相等"(!==)
    //算法：先求严格相等运算符的结果，然后返回相反值
    console.log('[严格不相等运算符]---', 1 !== '1'); //true
    //等同于
    console.log('[严格不相等运算符]---', !(1 === '1')); //true
}

//6---相等运算符
{
    //比较相等相同类型的数据时，与严格相等运算符完全一样
    //比较不同类型的数据时，先将数据进行类型转换，然后再用严格相等运算符比较
    //6.1---原始类型值
    {
        //原始类型值会转换成数值再进行比较
        console.log('[相等运算符]---原始类型值 ', 1 == true); //true
        //等同于
        console.log('[相等运算符]---原始类型值 ', 1 === Number(true)); //true
        console.log('[相等运算符]---原始类型值 ', 'true' == true); //false
        //等同于
        console.log('[相等运算符]---原始类型值 ', Number('true') === Number(true)); //false
        console.log('[相等运算符]---原始类型值 ', NaN === 1); //false
    }
    //6.2---对象(广义，包含数组和函数)与原始类型值比较
    {
        //对象转换成原始类型的值，再进行比较
        //对象与数值比较时，对象转为数值
        {
            console.log('[相等运算符]---对象与原始类型值比较 ', [1] == 1); //true
            //等同于
            console.log('[相等运算符]---对象与原始类型值比较 ', Number([1]) === 1); //true
        }
        //对象与字符串比较时，对象转为字符串
        console.log('[相等运算符]---对象与原始类型值比较 ', [1, 2] == '1,2'); //true
        //等同于
        console.log('[相等运算符]---对象与原始类型值比较 ', String([1, 2]) === '1,2'); //true
        //对象与布尔值比较时，2边都转为数值
        console.log('[相等运算符]---对象与原始类型值比较 ', [1] === true); //false
        //等同于
        console.log('[相等运算符]---对象与原始类型值比较 ', Number([1]) === true); //false
    }
    //6.3---undefined和null
    {
        //undefined和null与其他类型的值比较时，结果都为false，它们相互比较时结果为true
        console.log('[相等运算符]---undefined和null ', undefined == null); //true
        console.log('[相等运算符]---undefined和null ', 0 == null); //false
        console.log('[相等运算符]---undefined和null ', 0 == undefined); //false
    }
    //6.4---相等运算符的缺点
    {
        //相等运算符隐藏的类型转换，会带来一些违反直觉的结果
        console.log('[相等运算符]---缺点 ', 0 == ''); //true
        console.log('[相等运算符]---缺点 ', 0 == '0'); //true
    }
}

//7---不相等运算符
{
    //相等运算符有一个对应的"不相等运算符"(!=)
    //算法：先求相等运算符的结果，然后返回相反值
    console.log('[不相等运算符]---', 1 != '1'); //false
    //等同于
    console.log('[不相等运算符]---', !(1 == '1')); //false
}